排序算法的关键指标

时空复杂度 时间复杂度和空间复杂度 
排序稳定性 

对于序列中的相同元素 如果排序之后它们的相对位置没有发生改变 则称之为稳定排序 反之为不稳定排序 

是否原地排序 
原地排序就是指排序过程中不需要额外的辅助空间 只需要常数级别的额外空间 直接操作原数组进行排序 

注意，关键是是否需要额外的空间，而不是是否返回一个新的数组。具体来说就是类似这样的区别：

// 非原地排序
void sort(int[] nums) {
    // 排序过程中需要额外的辅助数组，消耗 O(N) 的空间
    int[] tmp = new int[nums.length];

    // 对 nums 进行排序
    for ...
}

// 原地排序
void sort(int[] nums) {
    // 直接操作 nums，不需要额外的辅助数组，消耗 O(1) 的空间
    for ...
}

选择排序 
先遍历一遍数组，找到数组中的最小值，然后把它和数组的第一个元素交换位置；接着再遍历一遍数组，找到第二小的元素，和数组的第二个元素交换位置；以此类推，直到整个数组有序。

这个算法有一个被大家熟知的名字，叫做「选择排序」，即每次都去遍历选择最小的元素。写成代码就是这样的：

void sort(int [] nums){
    int n= nums.length;
    int sortedIndex = 0;
    while(sortedIndex<n){
      int minIndex = sortedIndex;
      for(int i = sortedIndex+1;i<n;i++){
          if(nums[i]<nums[minIndex]){
            minIndex = i;
          }
      }
      int temp = nums[sortedIndex];
      nums[sortedIndex] = nums[minIndex];
      nums[minIndex] = temp;

      sortedIndex++;
    }
}


冒泡排序 
算是选择排序的一种优化 通过交换 nums[sortedIndex] 右侧的逆序对完成排序 
是一种稳定排序算法


void sort（int[] nums）{
    int n = nums.length;
    int sortedIndex = 0;
    while(sortedIndex < n){
        boolean swapped = false;
        for(int i = n-1 ; i>sortedIndex;i--){
        if(nums[i]<nums[i-1]){
          int tmp = nums[i];
          nums[i] = nums[i-1];
          nums[i-1] = tmp;
          swapped = true;
          
        }
        }
        if(!swapped){
        break;
        }
        sortedIndex++;
    }
}

还是o（n^2）并没有降低

插入排序是基于选择排序的一种优化 将nums[sortedIndex]插入到左侧的有序数组中，对有序度较高的数组 ，插入排序的效率比较高 

对选择排序进行进一步优化 向左侧有序数组中插入元素 
这个算法有另一个名字 就是插入排序 

void sort（int [] nums）{
    int n = nums.length;
    int sortedIndex = 0;
    //维护[0,sortedIndex)是有序数组 
    while(sortedIndex < n){
        for(int i = sortedIndex;i>0;i--){
        if(nums[i]<nums[i-1]){
            int tmp= num[i];
            nums[i] = nums[i-1];
            nums[i-1] = tmp;
        }else{
        break;
        }
        }
        sortedIndex++;
    }
}

显然，插入排序的效率和输入数组的有序度有很大关系，可以举极端例子来理解：

如果输入数组已经有序，或者仅有个别元素逆序，那么插入排序的内层 for 循环几乎不需要执行元素交换，所以时间复杂度接近 
O
(
n
)
O(n)。

如果输入的数组是完全逆序的，那么插入排序的效率就会很低，内层 for 循环每次都要对 nums[0..sortedIndex-1] 的所有元素进行交换，算法的总时间复杂度就接近 
O
(
n
2
)
O(n 
2
 )。

如果对比插入排序和冒泡排序，插入排序的综合性能应该要高于冒泡排序。

直观地说，插入排序的内层 for 循环，只需要对 sortedIndex 左侧 nums[0..sortedIndex-1] 这部分有序数组进行遍历和元素交换，大部分非极端情况下，可能不需要遍历完 nums[0..sortedIndex-1] 的所有元素；而冒泡排序的内层 for 循环，每次都需要遍历sortedIndex 右侧 nums[sortedIndex..] 的所有元素。

所以冒泡排序的操作数大约是 
n
2
/
2
n 
2
 /2，而插入排序的操作数会小于 
n
2
/
2
n 
2
 /2。

你可以把插入排序的代码拿去力扣第 912 题「排序数组」提交，它最终依然会超时，但可以说明算法代码的逻辑是正确的。之后的文章我们继续探讨如何对排序算法进行优化。


希尔排序 希尔排序是基于插入排序的简单改进 通过预处理增加数组的局部有序性 突破了插入排序的o（n2）

必须承认，希尔排序的思路很难想到，我是在《算法 4》第一次了解到这个算法，然后惊叹于这个算法的简单优化竟然能给插入排序带来如此大的提升。

首先我们要明确一个 h 有序数组 的概念。
一个数组是 h 有序的，是指这个数组中任意间隔为 h（或者说间隔元素的个数为 h-1）的元素都是有序的。


希尔排序
我在前文 
插入排序 分析过，插入排序对于有序度较高的数组效率很高，直逼 
O
(
n
)
O(n)，但对于有序度低（元素分布较随机）的数组就只有 
O
(
n
2
)
O(n 
2
 ) 了。

是否可以优化插入排序，使得即便有序度很低时，其时间复杂度也低于 
O
(
n
2
)
O(n 
2
 ) 呢？

希尔排序要发表看法了

你插入排序的问题是，上来就想着一步到位，直接把乱序数组变成 1 有序数组。而我希尔排序不着急，比方说，我先把乱序数组变成一个 16 有序数组，然后再变成 8 有序数组，4 有序数组，2 有序数组，最后变成 1 有序数组，完成排序。

这个 1, 2, 4, 8, 16... 的序列称之为「递增函数」，我上面举的例子的递增函数就是 
2
k
−
1
2 
k−1
 。

那么如何把一个数组变成 h 有序数组呢？基于插入排序的代码改动几个地方就行了，直接看希尔排序的代码吧：


